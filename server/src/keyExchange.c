#include <keyExchange.h>
#include <string.h>
#include <dlog.h>

#include "C_CkDh.h"
#include "C_CkCrypt2.h"

#ifndef EXTAPI
#define EXTAPI __attribute__((visibility("default")))
#endif

static HCkDh dhAlice;
static BOOL success;
static const char *eAlice;
static const char *kBob;
static const char *kAlice;
static HCkCrypt2 crypt;
static const char *sessionKey;
static const char *iv;
static const char *plainText;

EXTAPI void secure_key_exchange(const char* p, int g)
{
  //  Create two separate instances of the DH object.
  dhAlice = CkDh_Create();

  //  Unlock the component once at program startup...
  success = CkDh_UnlockComponent(dhAlice, "Anything for 30-day trial");
  if (success != TRUE) {
		ALOGD("%s", CkDh_lastErrorText(dhAlice));
		CkDh_Dispose(dhAlice);
		return;
  }

  //  The DH algorithm begins with a large prime, P, and a generator, G.
  //  These don't have to be secret, and they may be transmitted over an insecure channel.
  //  The generator is a small integer and typically has the value 2 or 5.

  //  The Chilkat DH component provides the ability to use known
  //  "safe" primes, as well as a method to generate new safe primes.

  //  This example will use a known safe prime.  Generating
  //  new safe primes is a time-consuming CPU intensive task
  //  and is normally done offline.

  //  Bob will choose to use the 2nd of our 8 pre-chosen safe primes.
  //  It is the Prime for the 2nd Oakley Group (RFC 2409) --
  //  1024-bit MODP Group.  Generator is 2.
  //  The prime is: 2^1024 - 2^960 - 1 + 2^64 * { [2^894 pi] + 129093 }
  //CkDh_UseKnownPrime(dhBob,2);

  //  The computed shared secret will be equal to the size of the prime (in bits).
  //  In this case the prime is 1024 bits, so the shared secret will be 128 bytes (128 * 8 = 1024).
  //  However, the result is returned as an SSH1-encoded bignum in hex string format.
  //  The SSH1-encoding prepends a 2-byte count, so the result is going  to be 2 bytes
  //  longer: 130 bytes.  This results in a hex string that is 260 characters long (two chars
  //  per byte for the hex encoding).

  //  Alice calls SetPG to set P and G.  SetPG checks
  //  the values to make sure it's a safe prime and will
  //  return FALSE if not.
  success = CkDh_SetPG(dhAlice, p, g);
  if (success != TRUE) {
		ALOGD("P is not a safe prime");
		CkDh_Dispose(dhAlice);
		return;
  }
}

EXTAPI const char* secure_find_key(const char* eBob)
{
	//  Each side begins by generating an "E"
  //  value.  The CreateE method has one argument: numBits.
  //  It should be set to twice the size of the number of bits
  //  in the session key.

  //  Let's say we want to generate a 128-bit session key
  //  for AES encryption.  The shared secret generated by the Diffie-Hellman
  //  algorithm will be longer, so we'll hash the result to arrive at the
  //  desired session key length.  However, the length of the session
  //  key we'll utlimately produce determines the value that should be
  //  passed to the CreateE method.

  //  In this case, we'll be creating a 128-bit session key, so pass 256 to CreateE.
  //  This setting is for security purposes only -- the value
  //  passed to CreateE does not change the length of the shared secret
  //  that is produced by Diffie-Hellman.
  //  Also, there is no need to pass in a value larger
  //  than 2 times the expected session key length.  It suffices to
  //  pass exactly 2 times the session key length.

  //  Bob generates a random E (which has the mathematical
  //  properties required for DH).
  
  //  Alice does the same:
  eAlice = CkDh_createE(dhAlice, 256);

  //  The "E" values are sent over the insecure channel.
  //  Bob sends his "E" to Alice, and Alice sends her "E" to Bob.

  //  Each side computes the shared secret by calling FindK.
  //  "K" is the shared-secret.

  //  Alice computes the shared secret from Bob's "E":
  kAlice = CkDh_findK(dhAlice, eBob);

  //  Amazingly, kBob and kAlice are identical and the expected
  //  length (260 characters).  The strings contain the hex encoded bytes of
  //  our shared secret:
  ALOGD("Alice's shared secret (should be equal to Bob's)");
  ALOGD("%s", kAlice);
  return eAlice;
}

EXTAPI void secure_aes_cbc_init(void)
{
  //  To arrive at a 128-bit session key for AES encryption, Bob and Alice should
  //  both transform the raw shared secret using a hash algorithm that produces
  //  the size of session key desired.   MD5 produces a 16-byte (128-bit) result, so
  //  this is a good choice for 128-bit AES.

  //  Here's how you would use Chilkat Crypt (a separate Chilkat component) to
  //  produce the session key:
  crypt = CkCrypt2_Create();
  success = CkCrypt2_UnlockComponent(crypt, "Anything for 30-day trial.");
  if (success != TRUE) {
		ALOGD("%s",CkCrypt2_lastErrorText(crypt));
		CkDh_Dispose(dhAlice);
		CkCrypt2_Dispose(crypt);
		return;
  }

  CkCrypt2_putEncodingMode(crypt, "hex");
  CkCrypt2_putHashAlgorithm(crypt, "md5");

  sessionKey = CkCrypt2_hashStringENC(crypt, kAlice);
  ALOGD("128-bit Session Key:");
  ALOGD("%s", sessionKey);

  //  Encrypt something...
  CkCrypt2_putCryptAlgorithm(crypt, "aes");
  CkCrypt2_putKeyLength(crypt, 128);
  CkCrypt2_putCipherMode(crypt, "cbc");

  //  Use an IV that is the MD5 hash of the session key...
  iv = CkCrypt2_hashStringENC(crypt, sessionKey);

  //  AES uses a 16-byte IV:
  ALOGD("Initialization Vector:");
  ALOGD("%s", iv);

  CkCrypt2_SetEncodedKey(crypt,sessionKey, "hex");
  CkCrypt2_SetEncodedIV(crypt,iv, "hex");

  //  Encrypt some text:
  CkCrypt2_putEncodingMode(crypt, "base64");
}

EXTAPI const char* secure_aes_cbc_decrypt(const char *cipherText64)
{
  plainText = CkCrypt2_decryptStringENC(crypt, cipherText64);
  return plainText;
}

EXTAPI void secure_aes_cbc_dispose(void)
{
  CkDh_Dispose(dhAlice);
  CkCrypt2_Dispose(crypt);
}
